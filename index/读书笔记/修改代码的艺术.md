---
aliases: 修改代码的艺术
tags:
  - 读书笔记/修改代码的艺术
date updated: 2024-05-27 21:38
---

## 修改代码的原因

- 添加新特性
- 修正bug
- 改善设计 改变既有软件的结构和组织，以另其更易于维护
- 优化  减少资源使用，内存、时间等

## 修改的风险

- 我们要进行哪些修改
- 我们如何得知已经正确地完成了修改
- 我们如何得知没有破坏任何（既有的）东西

## 修改的方式

### 编辑并祈祷

仔细的计划你所需要进行的改动，并确保自己理解了将要修改的代码，然后再开始改动。结束之后，运行修改后的系统，看看所做的改动是否生效，在然后对系统整体的验证，以确保改动没有破坏什么东西。

### 覆盖并修改

将测试覆盖在我们修改的代码上面，以确保糟糕的改动不会泄露出去并感染到软件的其他部分。这样就可以放心对它进行修改，并快速验出修改是好是坏。==通过测试来检验变化==。

重构修改步骤

1. 确定改动点
2. 找出测试点
3. 解依赖
4. 编写测试
5. 修改、重构

## 单元测试

关心的是一个系统的最为`原子`的行为单元，好的设计应当是可测试的。==试图使一个方法变得可测试这一行为本身就能够改善代码的质量==

好的单元测试应具备：

1. 隔离性
2. 运行快
3. 能帮助我们快速定位问题所在

以下不属于单元测试：

1. 跟数据库有交互
2. 进行了网络间通信
3. 调用了文件系统
4. 需要对环境做特定的准备（如编辑配置文件）才能运行的。

构建单元测试时一些技巧：

1. 使用null或空对象来构建参数

## 依赖性

依赖性是软件开发中最为关键的问题之一，在修改代码的过程中很大一部分工作都是围绕着 `解除依赖性以使改动变得更容易` 这个目标来进行的。而编写单元测试，有助于我们解除依赖性

尽量避免在你的代码中到处出现对库的直接调用。

好的代码除了要能在生成环境运行之外，还要能在测试环境中运行。针对生成环境而添加在代码上的约束常常导致代码在测试环境中寸步难行。

## 修改代码的技术

### 新生方法

当需要往一个系统中添加特性且这个特性完全可以用全新的代码来编写时，建议将这些代码放在一个新的方法中，并在需要用到这个新功能的地方调用这一方法。

实施这个技术的步骤

1. 确定修改点
2. 如果你的修改可以在一个方法中的已出地方以单块连续的语句序列出现，那么在修改点插入一个方法调用，而被调用的就是我们要编写的，用于完成工作的新方法。我们将这一调用先注释掉
3. 确定你需要原方法的那些局部变量，并将它们作为实参传给新方法调用
4. 确定新方法是否需要返回什么值给原方法，如果需要的话就得相应的修改对它的调用，使用一个变量来接受其返回值。
5. 使用测试驱动的开发方式来开发新的方法
6. 使原方法中被注释掉的调用重新生效

优点： 新旧代码被清晰地隔离开，能单独关注所要做的改动，并在新旧代码之间建立清晰地接口，你会看到所有被影响到的变量，更容易确定新的代码在上下文中是否是正确的。

缺点： 原方法测试覆盖范围变化，代码分散

### 外覆方法

当我们想要为原方法添加新行为时，可以创建一个与原方法同名的新方法，并在新方法中调用更名后的原方法。

实施步骤：

1. 确定待修改的方法
2. 如果你的修改可以在一处地方以单块连续的语句序列出现，那么将修改方法重命名，并使用其原先的名字和签名创建一个新方法。
3. 在新方法中调用冲命名后的原方法
4. 为欲添加的新特性编写一个方法，并在第二步创建的新方法中调用这个方法

优点： 新功能独立于既有功能
缺点： 糟糕的命名，新特性无法和旧特性交融在一起，要么在旧特性之前王，要么在之后完成。

### 测试驱动开发

设想有一个方法，能够帮助我们解决问题的某个部分，接下来我们为这个想象中的方法编写一个失败测试用例。此时该方法尚不存在，但既然我们能够为它编写测试，我们就对接下来将要编写的代码要做什么事情有一个确定的认识

实施步骤：

1. 编写一个测试用例
2. 让他通过编译
3. 让测试通过
4. 消除重复
5. 重复上述步骤

### 特征测试

特征测试刻画了一块代码的实际行为，而不是代码应该具有这一行为。在编写特征测试的时候如果发现某些结果与我们所期望的不一致，最好弄清它，因为我们遇到的可能是个bug。你的测试应当起到信息传递媒介的作用，别人一看到你的测试就能够知道对于某方法他们该期望什么而不该期望什么。

编写特殊测试的步骤：

1. 为准备修改的代码区域编写测试，直到你已经理解了那块代码的行为
2. 考虑你所要进行的修改，并针对修改编写测试
3. 如果想要提取或转移某些功能，那就编写测试来验证这些行为的存在性和一致性。

### 修改时应当测试那些方法

1. 编写[[#特征测试]]来固定住已有的行为
2. 推测代码修改所产生的影响，影响到该函数的返回值，并进而影响到调用该函数的返回值，直到遇到系统边界为止
3. 前向推测，面对一个方法，试图搞清楚如果它们停止工作的话下游会发生什么情况
4. 影响在代码中的传递有三种基本途径：
   1. 调用放使用被调用函数的返回值
   2. 修改传参传进来的对象，且后者接下来会被使用到
   3. 修改后面会被用到的静态或全局数据

修改代码所造成的影响使用如下的步骤：

1. 确定一个将要修改的方法
2. 如果该方法由返回值，查看它的调用方
3. 看看该方法是否修改了什么值，查看其它使用了这些值的方法，以及使用了这些方法的方法
4. 查看父类和子类，它们也可能使用了这些实例变量和方法
5. 查看这些方法的参数，看着你要修改的代码是否使用了某参数对象或它的方法锁返回的对象
6. 找出到目前为止被你所找出的任何方法修改的全局变量和静态数据

### 通过测试来理解代码

用于刻画代码的测试，描述了系统实际的行为

1. 寻找代码中逻辑复杂的部分，如果不理解某块代码，可以考虑引入[[#感知变量]]来刻画它。利用 [[#感知变量]] 来确保代码中的某些特定的区域被执行到了
2. 随着你不断发现类或方法的一个个职责，不时停下来把你认为可能出错的地方列出一个单子。看看能不能编写出能够触发这些问题的测试。
3. 考虑你在测试中提供的输入。如果故意把输入的值变得极端化会出现什么情况
4. 对于某个类的对象，有没有某些条件在它的整个生命周期当中都是成立的。

和编写文档一样，你在编写特征测试的时候也得考虑哪些东西对于阅读它们的人来说是重要的。一开始防止一些简单的，用于说明目标类的主要意图的测试用例。然后在突出该类宇宙不同的地方的用例。确保你所发现的那些重要的地方都以测试的形式呈现出来。

### API调用

如何正确的使用API

1. 剥离并[[#外覆方法|外覆]]API，编写能够尽量准确对应API的接口，做到不依赖底层的API代码
2. 基于职责的提取

### 依赖收集

编写测试来保护你要保护的关键逻辑，提取出你的测试所没有覆盖的部分，将重要行为与其他行为隔离开

### 提取代码

当将代码提取为一个方法时，不要选择太大的代码块，如果[[#耦合数]]大于0，那么通常使用一个[[#感知变量]]是有好处的。

### 接口提取

接口提取是最安全的解依赖技术之一。接口提取的关键在于为你的类创建一个接口，该接口包含你想要在某些上下文中使用的所有方法，完成接口后，就可以让你的类实现它。

接口提取的步骤：

1. 创建一个新接口，给它起一个好名字，暂时不要往里面添加任何方法
2. 令你提取的接口的目标类实现该接口
3. 将你想要使用伪对象的地方从引用原类改为引用你新建的接口
4. 编译系统，如果编译器提示接口缺少某某方法，则添加相应的方法，直到编译通过

## 设计准则

### 命令查询分离

一个方法要么是一个命令，要么是一个查询，但不能两者都是。命令式方法指那些会改变对象状态但并不返回值的方法，而查询式方法是指那些有返回值但不会改变对象状态的方法。如果一个方法是查询式的，那么无需查看其方法体就可以知道连续多次调用使用它而不用担心会带来什么副作用。

## 名词解释

### 感知变量

添加一个变量并使用它来感知待重构方法内的条件，而在完成重构之后则可以将变量删除。

### 耦合数

可以用传进传出的方法的值的总数例如方法的参数、方法的返回值的总数，对于成员变量的方法可以不计算为耦合数。

### 拦截点

可以编写测试来感知某些条件的点

### 接缝

程序中一些特殊的点，在这些点上你无需做任何代码修改就可以达到改动程序行为的目的。
