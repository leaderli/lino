---
aliases: 字节码,class
tags:
  - java/jvm/字节码
date updated: 2024-08-18 14:53
---

class字节码文件是java跨平台的基础，其本质是一个满足JVM规范的二进制文件。class文件以一个个8位字节位基础单位，每个数据严格按照指定的数据结构排列在class文件之中。

## 类文件的数据结构

```c++
ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

- `u4` `u2`表示占用4字节和2字节
- `info` 表示指针

对下述代码编译

```java
public class Hello {
	public static void main(String[] args) {
        System.out.println("hello");
	}
}
```

得到 hello.class文件，我们查看其二进制内容

```http
  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F 	
00000000: CA FE BA BE 00 00 00 34 00 1D 0A 00 06 00 0F 09 00 10 00 11 08 00 12 0A 00 13 00 14 07 00 15 07    J~:>...4........................
00000020: 00 16 01 00 06 3C 69 6E 69 74 3E 01 00 03 28 29 56 01 00 04 43 6F 64 65 01 00 0F 4C 69 6E 65 4E    .....<init>...()V...Code...LineN
00000040: 75 6D 62 65 72 54 61 62 6C 65 01 00 04 6D 61 69 6E 01 00 16 28 5B 4C 6A 61 76 61 2F 6C 61 6E 67    umberTable...main...([Ljava/lang
00000060: 2F 53 74 72 69 6E 67 3B 29 56 01 00 0A 53 6F 75 72 63 65 46 69 6C 65 01 00 0A 48 65 6C 6C 6F 2E    /String;)V...SourceFile...Hello.
00000080: 6A 61 76 61 0C 00 07 00 08 07 00 17 0C 00 18 00 19 01 00 05 68 65 6C 6C 6F 07 00 1A 0C 00 1B 00    java................hello.......
000000a0: 1C 01 00 05 48 65 6C 6C 6F 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74 01 00 10 6A    ....Hello...java/lang/Object...j
000000c0: 61 76 61 2F 6C 61 6E 67 2F 53 79 73 74 65 6D 01 00 03 6F 75 74 01 00 15 4C 6A 61 76 61 2F 69 6F    ava/lang/System...out...Ljava/io
000000e0: 2F 50 72 69 6E 74 53 74 72 65 61 6D 3B 01 00 13 6A 61 76 61 2F 69 6F 2F 50 72 69 6E 74 53 74 72    /PrintStream;...java/io/PrintStr
00000100: 65 61 6D 01 00 07 70 72 69 6E 74 6C 6E 01 00 15 28 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69    eam...println...(Ljava/lang/Stri
00000120: 6E 67 3B 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 00 07 00 08 00 01 00 09 00 00 00 1D 00    ng;)V.!.........................
00000140: 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 01 00 0A 00 00 00 06 00 01 00 00 00 01 00 09 00 0B    .......*7..1....................
00000160: 00 0C 00 01 00 09 00 00 00 25 00 02 00 01 00 00 00 09 B2 00 02 12 03 B6 00 04 B1 00 00 00 01 00    .........%........2....6..1.....
00000180: 0A 00 00 00 0A 00 02 00 00 00 03 00 08 00 04 00 01 00 0D 00 00 00 02 00 0E                         .........................
```

根据数据结构的定义，前4位是magic，固定为 `CAFEBABE`，用于JVM认定该文件为一个合法的class字节码，通过第8位也可以看到其编译的 [[major_version|java 版本信息]]

一般为了方便我们都使用  [[index/java/command#javap|javap]] 查看class字节码，查看
[[index/java/command#^e7cce6|示例]] 我们可以方便的看到其 [[major_version|java 版本信息]]

## 描述符

在jvm规范中，每个变量、字段都有描述信息，描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。
根据描述符规则，基本数据类型（ `byte`、`char`、`double`、`float`、`int`、`long`、`short`、`boolean` ）以及代表无返回值的 `void` 类型都用一个大写字符 `V` 来表示，而对象类型则用字符`L` 加对象的全限定名来表示，详见下表:

| 标志符  | 含义                        |
| :--- | :------------------------ |
| B    | 基本数据类型 byte               |
| C    | 基本数据类型 char               |
| D    | 基本数据类型 double             |
| F    | 基本数据类型 float              |
| I    | 基本数据类型 int                |
| J    | 基本数据类型 long               |
| S    | 基本数据类型 short              |
| Z    | 基本数据类型 boolean            |
| V    | 基本数据类型 void               |
| L    | 对象类型,如 Ljava/lang/Object  |
| `[*` | 数组类型,如 [Ljava/lang/Object |

方法的描述符，先参数列表后返回值的顺序来描述，参数列表按参数顺序放在 `()` 之间。

通过查看  [[index/java/command#^e7cce6|示例]] ，我们观察到 [[constant pool| 常量池]] 中字段的描述符，也可以看到方法的描述符。例如最常见的main方法的描述符，`descriptor: ([Ljava/lang/String;)V`

描述符示例：

- `public void method(): ()V`
- `public void method(String s, int i): (Ljava/lang/String;I)V`
- `public String method(String s, int i, boolan flag):(Ljava/lang/String;IZ)Ljava/lang/String`

## 常用字节码指令

### ldc

`int`, `float` 或 `String` 型常量从常量池推送至栈顶

### getstatic

获取类的静态字段，将其值压入栈顶

### putstatic

给类的静态字段赋值

## 示例

### 查看 Class 是否是基本类型

```java
clasz.isPrimitive();
```

### 判断类是否继承自

```java
Father.class.isAssignableFrom(Son.class)
```

## 字节码编辑软件

![[Pasted image 20240206211329.png]]

[JBE - Java Bytecode Editor](https://set.ee/jbe/)

## 字节码指令表

字节码指令根据功能、属性不同，可以分为11大类。下面附上字节码指令的分类，用于简单、临时查看，字节码指令的详细介绍，还需要查看官网的介绍。

### 4.1 Constants 常量相关

|     |      |             |                                          |
| --- | ---- | ----------- | ---------------------------------------- |
| 十进制 | 操作码  | 助记符         | 含义                                       |
| 00  | 0x00 | nop         | 什么都不做                                    |
| 01  | 0x01 | aconst_null | 把 null 推到操作数栈                            |
| 02  | 0x02 | iconst_m1   | 把 int 常量 –1 推到操作数栈                       |
| 03  | 0x03 | iconst_0    | 把 int 常量 0 推到操作数栈                        |
| 04  | 0x04 | iconst_1    | 把 int 常量 1 推到操作数栈                        |
| 05  | 0x05 | iconst_2    | 把 int 常量 2 推到操作数栈                        |
| 06  | 0x06 | iconst_3    | 把 int 常量 3 推到操作数栈                        |
| 07  | 0x07 | iconst_4    | 把 int 常量 4 推到操作数栈                        |
| 08  | 0x08 | iconst_5    | 把 int 常量 5 推到操作数栈                        |
| 09  | 0x09 | lconst_0    | 把 long 常量 0 推到操作数栈                       |
| 10  | 0x0A | lconst_1    | 把 long 常量 1 推到操作数栈                       |
| 11  | 0x0B | fconst_0    | 把 float 常量 0 推到操作数栈                      |
| 12  | 0x0C | fconst_1    | 把 float 常量 1 推到操作数栈                      |
| 13  | 0x0D | fconst_2    | 把 float 常量 2 推到操作数栈                      |
| 14  | 0x0E | dconst_0    | 把 double 常量 0 推到操作数栈                     |
| 15  | 0x0F | dconst_1    | 把 double 常量 1 推到操作数栈                     |
| 16  | 0x10 | bipush      | 把单字节常量（-128~127）推到操作数栈                   |
| 17  | 0x11 | sipush      | 把 short 常量（-32768~32767）推到操作数栈           |
| 18  | 0x12 | ldc         | 把常量池中的int，float，String型常量取出并推到操作数栈顶      |
| 19  | 0x13 | ldc_w       | 把常量池中的int，float，String型常量取出并推到操作数栈顶（宽索引） |
| 20  | 0x14 | ldc2_w      | 把常量池中的long，double型常量取出并推到操作数栈顶（宽索引）      |

### 4.2 Loads 加载相关

|     |      |         |                               |
| --- | ---- | ------- | ----------------------------- |
| 十进制 | 操作码  | 助记符     | 含义                            |
| 21  | 0x15 | iload   | 把 int 型局部变量推到操作数栈             |
| 22  | 0x16 | lload   | 把 long 型局部变量推到操作数栈            |
| 23  | 0x17 | fload   | 把 float 型局部变量推到操作数栈           |
| 24  | 0x18 | dload   | 把 double 型局部变量推到操作数栈          |
| 25  | 0x19 | aload   | 把引用型局部变量推到操作数栈                |
| 26  | 0x1A | iload_0 | 把局部变量第 1 个 int 型局部变量推到操作数栈    |
| 27  | 0x1B | iload_1 | 把局部变量第 2 个 int 型局部变量推到操作数栈    |
| 28  | 0x1C | iload_2 | 把局部变量第 3 个 int 型局部变量推到操作数栈    |
| 29  | 0x1D | iload_3 | 把局部变量第 4 个 int 型局部变量推到操作数栈    |
| 30  | 0x1E | lload_0 | 把局部变量第 1 个 long 型局部变量推到操作数栈   |
| 31  | 0x1F | lload_1 | 把局部变量第 2 个 long 型局部变量推到操作数栈   |
| 32  | 0x20 | lload_2 | 把局部变量第 3 个 long 型局部变量推到操作数栈   |
| 33  | 0x21 | lload_3 | 把局部变量第 4 个 long 型局部变量推到操作数栈   |
| 34  | 0x22 | fload_0 | 把局部变量第 1 个 float 型局部变量推到操作数栈  |
| 35  | 0x23 | fload_1 | 把局部变量第 2 个 float 型局部变量推到操作数栈  |
| 36  | 0x24 | fload_2 | 把局部变量第 3 个 float 型局部变量推到操作数栈  |
| 37  | 0x25 | fload_3 | 把局部变量第 4 个 float 型局部变量推到操作数栈  |
| 38  | 0x26 | dload_0 | 把局部变量第 1 个 double 型局部变量推到操作数栈 |
| 39  | 0x27 | dload_1 | 把局部变量第 2 个 double 型局部变量推到操作数栈 |
| 40  | 0x28 | dload_2 | 把局部变量第 3 个 double 型局部变量推到操作数栈 |
| 41  | 0x29 | dload_3 | 把局部变量第 4 个 double 型局部变量推到操作数栈 |
| 42  | 0x2A | aload_0 | 把局部变量第 1 个引用型局部变量推到操作数栈       |
| 43  | 0x2B | aload_1 | 把局部变量第 2 个引用型局部变量推到操作数栈       |
| 44  | 0x2C | aload_2 | 把局部变量第 3 个引用型局部变量推到操作数栈       |
| 45  | 0x2D | aload_3 | 把局部变量第 4 个引用 型局部变量推到操作数栈      |
| 46  | 0x2E | iaload  | 把 int 型数组指定索引的值推到操作数栈         |
| 47  | 0x2F | laload  | 把 long 型数组指定索引的值推到操作数栈        |
| 48  | 0x30 | faload  | 把 float 型数组指定索引的值推到操作数栈       |
| 49  | 0x31 | daload  | 把 double 型数组指定索引的值推到操作数栈      |
| 50  | 0x32 | aaload  | 把引用型数组指定索引的值推到操作数栈            |
| 51  | 0x33 | baload  | 把 boolean或byte型数组指定索引的值推到操作数栈 |
| 52  | 0x34 | caload  | 把 char 型数组指定索引的值推到操作数栈        |
| 53  | 0x35 | saload  | 把 short 型数组指定索引的值推到操作数栈       |

### 4.3 Store 存储相关

|     |      |          |                                   |
| --- | ---- | -------- | --------------------------------- |
| 十进制 | 操作码  | 助记符      | 含义                                |
| 54  | 0x36 | istore   | 把栈顶 int 型数值存入指定局部变量               |
| 55  | 0x37 | lstore   | 把栈顶 long 型数值存入指定局部变量              |
| 56  | 0x38 | fstore   | 把栈顶 float 型数值存入指定局部变量             |
| 57  | 0x39 | dstore   | 把栈顶 double 型数值存入指定局部变量            |
| 58  | 0x3A | astore   | 把栈顶引用型数值存入指定局部变量                  |
| 59  | 0x3B | istore_0 | 把栈顶 int 型数值存入第 1 个局部变量            |
| 60  | 0x3C | istore_1 | 把栈顶 int 型数值存入第 2 个局部变量            |
| 61  | 0x3D | istore_2 | 把栈顶 int 型数值存入第 3 个局部变量            |
| 62  | 0x3E | istore_3 | 把栈顶 int 型数值存入第 4 个局部变量            |
| 63  | 0x3F | lstore_0 | 把栈顶 long 型数值存入第 1 个局部变量           |
| 64  | 0x40 | lstore_1 | 把栈顶 long 型数值存入第 2 个局部变量           |
| 65  | 0x41 | lstore_2 | 把栈顶 long 型数值存入第 3 个局部变量           |
| 66  | 0x42 | lstore_3 | 把栈顶 long 型数值存入第 4 个局部变量           |
| 67  | 0x43 | fstore_0 | 把栈顶 float 型数值存入第 1 个局部变量          |
| 68  | 0x44 | fstore_1 | 把栈顶 float 型数值存入第 2 个局部变量          |
| 69  | 0x45 | fstore_2 | 把栈顶 float 型数值存入第 3 个局部变量          |
| 70  | 0x46 | fstore_3 | 把栈顶 float 型数值存入第 4 个局部变量          |
| 71  | 0x47 | dstore_0 | 把栈顶 double 型数值存入第 1 个局部变量         |
| 72  | 0x48 | dstore_1 | 把栈顶 double 型数值存入第 2 个局部变量         |
| 73  | 0x49 | dstore_2 | 把栈顶 double 型数值存入第 3 个局部变量         |
| 74  | 0x4A | dstore_3 | 把栈顶 double 型数值存入第 4 个局部变量         |
| 75  | 0x4B | astore_0 | 把栈顶 引用 型数值存入第 1 个局部变量             |
| 76  | 0x4C | astore_1 | 把栈顶 引用 型数值存入第 2 个局部变量             |
| 77  | 0x4D | astore_2 | 把栈顶 引用 型数值存入第 3 个局部变量             |
| 78  | 0x4E | astore_3 | 把栈顶 引用 型数值存入第 4 个局部变量             |
| 79  | 0x4F | iastore  | 把栈顶 int 型数值存入数组指定索引位置             |
| 80  | 0x50 | lastore  | 把栈顶 long 型数值存入数组指定索引位置            |
| 81  | 0x51 | fastore  | 把栈顶 float 型数值存入数组指定索引位置           |
| 82  | 0x52 | dastore  | 把栈顶 double 型数值存入数组指定索引位置          |
| 83  | 0x53 | aastore  | 把栈顶 引用 型数值存入数组指定索引位置              |
| 84  | 0x54 | bastore  | 把栈顶 boolean or byte 型数值存入数组指定索引位置 |
| 85  | 0x55 | castore  | 把栈顶 char 型数值存入数组指定索引位置            |
| 86  | 0x56 | sastore  | 把栈顶 short 型数值存入数组指定索引位置           |

### 4.4 Stack 栈相关

|     |      |         |                                            |
| --- | ---- | ------- | ------------------------------------------ |
| 十进制 | 操作码  | 助记符     | 含义                                         |
| 87  | 0x57 | pop     | 把栈顶数值弹出（非long，double数值）                    |
| 88  | 0x58 | pop2    | 把栈顶的一个long或double值弹出，或弹出2个其他类型数值           |
| 89  | 0x59 | dup     | 复制栈顶数值并把数值入栈                               |
| 90  | 0x5A | dup_x1  | 复制栈顶数值并将两个复制值压入栈顶                          |
| 91  | 0x5B | dup_x2  | 复制栈顶数值并将三个（或两个）复制值压入栈顶                     |
| 92  | 0x5C | dup2    | 复制栈顶一个（long 或double 类型的)或两个（其它）数值并将复制值压入栈顶 |
| 93  | 0x5D | dup2_x1 | dup_x1 指令的双倍版本                             |
| 94  | 0x5E | dup2_x2 | dup_x2 指令的双倍版本                             |
| 95  | 0x5F | swap    | 把栈顶端的两个数的值交换（数值不能是long 或double 类型< td >的）  |

### 4.5 Math 运算相关

Java 虚拟机在处理浮点数运算时，不会抛出任何运行时异常，当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN。

|     |      |       |                            |
| --- | ---- | ----- | -------------------------- |
| 十进制 | 操作码  | 助记符   | 含义                         |
| 96  | 0x60 | iadd  | 把栈顶两个 int 型数值相加并将结果入栈      |
| 97  | 0x61 | ladd  | 把栈顶两个 long 型数值相加并将结果入栈     |
| 98  | 0x62 | fadd  | 把栈顶两个 float 型数值相加并将结果入栈    |
| 99  | 0x63 | dadd  | 把栈顶两个 double 型数值相加并将结果入栈   |
| 100 | 0x64 | isub  | 把栈顶两个 int 型数值相减并将结果入栈      |
| 101 | 0x65 | lsub  | 把栈顶两个 long 型数值相减并将结果入栈     |
| 102 | 0x66 | fsub  | 把栈顶两个 float 型数值相减并将结果入栈    |
| 103 | 0x67 | dsub  | 把栈顶两个 double 型数值相减并将结果入栈   |
| 104 | 0x68 | imul  | 把栈顶两个 int 型数值相乘并将结果入栈      |
| 105 | 0x69 | lmul  | 把栈顶两个 long 型数值相乘并将结果入栈     |
| 106 | 0x6A | fmul  | 把栈顶两个 float 型数值相乘并将结果入栈    |
| 107 | 0x6B | dmul  | 把栈顶两个 double 型数值相乘并将结果入栈   |
| 108 | 0x6C | idiv  | 把栈顶两个 int 型数值相除并将结果入栈      |
| 109 | 0x6D | ldiv  | 把栈顶两个 long 型数值相除并将结果入栈     |
| 110 | 0x6E | fdiv  | 把栈顶两个 float 型数值相除并将结果入栈    |
| 111 | 0x6F | ddiv  | 把栈顶两个 double 型数值相除并将结果入栈   |
| 112 | 0x70 | irem  | 把栈顶两个 int 型数值模运算并将结果入栈     |
| 113 | 0x71 | lrem  | 把栈顶两个 long 型数值模运算并将结果入栈    |
| 114 | 0x72 | frem  | 把栈顶两个 float 型数值模运算并将结果入栈   |
| 115 | 0x73 | drem  | 把栈顶两个 double 型数值模运算并将结果入栈  |
| 116 | 0x74 | ineg  | 把栈顶 int 型数值取负并将结果入栈        |
| 117 | 0x75 | lneg  | 把栈顶 long 型数值取负并将结果入栈       |
| 118 | 0x76 | fneg  | 把栈顶 float 型数值取负并将结果入栈      |
| 119 | 0x77 | dneg  | 把栈顶 double 型数值取负并将结果入栈     |
| 120 | 0x78 | ishl  | 把 int 型数左移指定位数并将结果入栈       |
| 121 | 0x79 | lshl  | 把 long 型数左移指定位数并将结果入栈      |
| 122 | 0x7A | ishr  | 把 int 型数右移指定位数并将结果入栈（有符号）  |
| 123 | 0x7B | lshr  | 把 long 型数右移指定位数并将结果入栈（有符号） |
| 124 | 0x7C | iushr | 把 int 型数右移指定位数并将结果入栈（无符号）  |
| 125 | 0x7D | lushr | 把 long 型数右移指定位数并将结果入栈（无符号） |
| 126 | 0x7E | iand  | 把栈顶两个 int 型数值 按位与 并将结果入栈   |
| 127 | 0x7F | land  | 把栈顶两个 long 型数值 按位与 并将结果入栈  |
| 128 | 0x80 | ior   | 把栈顶两个 int 型数值 按位或 并将结果入栈   |
| 129 | 0x81 | lor   | 把栈顶两个 long 型数值 按或与 并将结果入栈  |
| 130 | 0x82 | ixor  | 把栈顶两个 int 型数值 按位异或 并将结果入栈  |
| 131 | 0x83 | lxor  | 把栈顶两个 long 型数值 按位异或 并将结果入栈 |
| 132 | 0x84 | iinc  | 把指定 int 型增加指定值             |

### 4.6 Conversions 转换相关

类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显示类型转换操作。

Java 虚拟机直接支持（即转换时无需显示的转换指令）小范围类型向大范围类型的安全转换，但在处理窄化类型转换时，必须显式使用转换指令来完成。

|     |      |     |                         |
| --- | ---- | --- | ----------------------- |
| 十进制 | 操作码  | 助记符 | 含义                      |
| 133 | 0x85 | i2l | 把栈顶 int 强转 long 并入栈     |
| 134 | 0x86 | i2f | 把栈顶 int 强转 float 并入栈    |
| 135 | 0x87 | i2d | 把栈顶 int 强转 double 并入栈   |
| 136 | 0x88 | l2i | 把栈顶 long 强转 int 并入栈     |
| 137 | 0x89 | l2f | 把栈顶 long 强转 float 并入栈   |
| 138 | 0x8A | l2d | 把栈顶 long 强转 double 并入栈  |
| 139 | 0x8B | f2i | 把栈顶 float 强转 int 并入栈    |
| 140 | 0x8C | f2l | 把栈顶 float 强转 long 并入栈   |
| 141 | 0x8D | f2d | 把栈顶 float 强转 double 并入栈 |
| 142 | 0x8E | d2i | 把栈顶 double 强转 int 并入栈   |
| 143 | 0x8F | d2l | 把栈顶 double 强转 long 并入栈  |
| 144 | 0x90 | d2f | 把栈顶 double 强转 float 并入栈 |
| 145 | 0x91 | i2b | 把栈顶 int 强转 byte 并入栈     |
| 146 | 0x92 | i2c | 把栈顶 int 强转 char 并入栈     |
| 147 | 0x93 | i2s | 把栈顶 int 强转 short 并入栈    |

### 4.7 Comparisons 比较相关

|     |      |           |                                                            |
| --- | ---- | --------- | ---------------------------------------------------------- |
| 十进制 | 操作码  | 助记符       | 含义                                                         |
| 148 | 0x94 | lcmp      | 比较栈顶两long 型数值大小，并将结果（1，0，-1）压入栈顶                           |
| 149 | 0x95 | fcmpl     | 比较栈顶两float 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为“NaN”时，将-1 压入栈顶  |
| 150 | 0x96 | fcmpg     | 比较栈顶两float 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为“NaN”时，将1 压入栈顶   |
| 151 | 0x97 | dcmpl     | 比较栈顶两double 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为“NaN”时，将-1 压入栈顶 |
| 152 | 0x98 | dcmpg     | 比较栈顶两double 型数值大小，并将结果（1，0，-1）压入栈顶；当其中一个数值为“NaN”时，将1 压入栈顶  |
| 153 | 0x99 | ifeq      | 当栈顶 int 型数值等于0时，跳转                                         |
| 154 | 0x9A | ifne      | 当栈顶 int 型数值不等于0时，跳转                                        |
| 155 | 0x9B | iflt      | 当栈顶 int 型数值小于0时，跳转                                         |
| 156 | 0x9C | ifge      | 当栈顶 int 型数值大于等于0时，跳转                                       |
| 157 | 0x9D | ifgt      | 当栈顶 int 型数值大于0时，跳转                                         |
| 158 | 0x9E | ifle      | 当栈顶 int 型数值小于等于0时，跳转                                       |
| 159 | 0x9F | if_icmpeq | 比较栈顶两个 int 型数值，等于0时，跳转                                     |
| 160 | 0xA0 | if_icmpne | 比较栈顶两个 int 型数值，不等于0时，跳转                                    |
| 161 | 0xA1 | if_icmplt | 比较栈顶两个 int 型数值，小于0时，跳转                                     |
| 162 | 0xA2 | if_icmpge | 比较栈顶两个 int 型数值，大于等于0时，跳转                                   |
| 163 | 0xA3 | if_icmpgt | 比较栈顶两个 int 型数值，大于0时，跳转                                     |
| 164 | 0xA4 | if_icmple | 比较栈顶两个 int 型数值，小于等于0时，跳转                                   |
| 165 | 0xA5 | if_acmpeq | 比较栈顶两个 引用 型数值，相等时跳转                                        |
| 166 | 0xA6 | if_acmpne | 比较栈顶两个 引用 型数值，不相等时跳转                                       |

### 4.8 Control 控制相关

控制转移指令可以让 Java 虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改 PC 寄存器的值。

|     |      |              |                                           |
| --- | ---- | ------------ | ----------------------------------------- |
| 十进制 | 操作码  | 助记符          | 含义                                        |
| 167 | 0xA7 | goto         | 无条件分支跳转                                   |
| 168 | 0xA8 | jsr          | 跳转至指定16 位offset（bit） 位置，并将jsr 下一条指令地址压入栈顶 |
| 169 | 0xA9 | ret          | 返回至局部变量指定的index 的指令位置（一般与jsr，jsr_w联合使用）   |
| 170 | 0xAA | tableswitch  | 用于switch 条件跳转，case 值连续（可变长度指令）            |
| 171 | 0xAB | lookupswitch | 用于switch 条件跳转，case 值不连续（可变长度指令）           |
| 172 | 0xAC | ireturn      | 结束方法，并返回一个int 类型数据                        |
| 173 | 0xAD | lreturn      | 从当前方法返回 long                              |
| 174 | 0xAE | freturn      | 从当前方法返回 float                             |
| 175 | 0xAF | dreturn      | 从当前方法返回 double                            |
| 176 | 0xB0 | areturn      | 从当前方法返回 对象引用                              |
| 177 | 0xB1 | return       | 从当前方法返回 void                              |

### 4.9 references 引用、方法、异常、同步相关

|     |      |                 |                                                                                                                                  |
| --- | ---- | --------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| 十进制 | 操作码  | 助记符             | 含义                                                                                                                               |
| 178 | 0xB2 | getstatic       | 获取指定类的静态域，并将其值压入栈顶                                                                                                               |
| 179 | 0xB3 | putstatic       | 为类的静态域赋值                                                                                                                         |
| 180 | 0xB4 | getfield        | 获取指定类的实例域（对象的字段值），并将其值压入栈顶                                                                                                       |
| 181 | 0xB5 | putfield        | 为指定的类的实例域赋值                                                                                                                      |
| 182 | 0xB6 | invokevirtual   | 调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），是Java语言中最常见的方法分派方式。                                                                               |
| 183 | 0xB7 | invokespecial   | 调用一些需要特殊处理的实例方法，包括实例初始化方法（）、私有方法和父类方法。这三类方法的调用对象在编译时就可以确定。                                                                       |
| 184 | 0xB8 | invokestatic    | 调用静态方法                                                                                                                           |
| 185 | 0xB9 | invokeinterface | 调用接口方法调，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。                                                                                      |
| 186 | 0xBA | invokedynamic   | 调用动态链接方法（该指令是指令是Java SE 7 中新加入的）。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 |
| 187 | 0xBB | new             | 创建一个对象，并将其引用值压入栈顶                                                                                                                |
| 188 | 0xBC | newarray        | 创建一个指定原始类型（如int、float、char……）的数组，并将其引用值压入栈顶                                                                                      |
| 189 | 0xBD | anewarray       | 创建一个引用型（如类，接口，数组）的数组，并将其引用值压入栈顶                                                                                                  |
| 190 | 0xBE | arraylength     | 获得数组的长度值并压入栈顶                                                                                                                    |
| 191 | 0xBF | athrow          | 将栈顶的异常直接抛出。Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，并且，在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成的。                            |
| 192 | 0xC0 | checkcast       | 检验类型转换，检验未通过将抛出ClassCastException                                                                                                |
| 193 | 0xC1 | instanceof      | 检验对象是否是指定的类的实例，如果是将1 压入栈顶，否则将0 压入栈顶                                                                                              |
| 194 | 0xC2 | monitorenter    | 获取对象的monitor，用于同步块或同步方法                                                                                                          |
| 195 | 0xC3 | monitorexit     | 释放对象的monitor，用于同步块或同步方法                                                                                                          |

Java 虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。

**方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。**虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 方法标志得知一个方法是否声明为同步方法。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。

**同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义**

编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。

### 4.10 Extended 扩展相关

|     |      |                |                                                     |
| --- | ---- | -------------- | --------------------------------------------------- |
| 十进制 | 操作码  | 助记符            | 含义                                                  |
| 196 | 0xC4 | wide           | 扩展访问局部变量表的索引宽度                                      |
| 197 | 0xC5 | multianewarray | 创建指定类型和指定维度的多维数组（执行该指令时，操作栈中必须包含各维度的长度值），并将其引用值压入栈顶 |
| 198 | 0xC6 | ifnull         | 为 null 时跳转                                          |
| 199 | 0xC7 | ifnonnull      | 非 null 时跳转                                          |
| 200 | 0xC8 | goto_w         | 无条件跳转（宽索引）                                          |
| 201 | 0xC9 | jsr_w          | 跳转指定32bit偏移位置，并将jsr_w下一条指令地址入栈                      |

### 4.11 Reserved 保留指令

|     |      |            |                 |
| --- | ---- | ---------- | --------------- |
| 十进制 | 操作码  | 助记符        | 含义              |
| 202 | 0xCA | breakpoint | 调试时的断点          |
| 254 | 0xFE | impdep1    | 用于在特定硬件中使用的语言后门 |
| 255 | 0xFF | impdep2    | 用于在特定硬件中使用的语言后门 |

## 参考文档

1. [Java字节码文件结构剖析 - cexo - 博客园](https://www.cnblogs.com/webor2006/p/9404249.html)
2. [Java字节码结构剖析一：常量池 - 简书](https://www.jianshu.com/p/bc3cfbebef25)
3. [JVM规范 Java SE8官方文档](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Fspecs%2Fjvms%2Fse8%2Fhtml%2Findex.html "https://docs.oracle.com/javase/specs/jvms/se8/html/index.html")
4. [JVM规范中《操作码助记符表》](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-7.html)
